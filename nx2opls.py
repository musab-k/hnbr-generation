######################################################
# nx-opls.py
#
# August 2014
# M Khawaja
#
# - Takes network of atoms from lmp2nx and assigns
#		OPLS properties
######################################################

import numpy as np
import lmp2nx as ln
import itertools as it
import copy

def define_opls_types(g, type_key, lammps_coefficients, fflocation='./gmx/'):
	defined_types = _define_initial_opls_types(g, fflocation=fflocation)
	new_defined_types = _refine_opls_types_from_bonds(g, defined_types, type_key,\
		lammps_coefficients, fflocation)
	return new_defined_types


def _define_initial_opls_types(g, fflocation='./gmx/'):
	"""	Defines bonded types to network of atoms and nodes created by lmp2nx(),
	based on the OPLS force-field implemented in Gromacs
		- Input:
			- network of atoms and bonds created by lmp2nx.lmp2nx()
			- location of ffnonbonded.itp for OPLS-AA provided
				by Gromacs
		- Output:
			- adds 'opls_bonded_type' to each atom in the network
			- returns
	"""

	with open(fflocation+'ffnonbonded.itp') as f:
		ls = np.array([l.strip().split()[:8] for l in f.readlines() if 'opls_' in l])

	nonbonded_types 	=	ls[:,0]
	bonded_types 		=	ls[:,1]
	mass		 	=	np.array(ls[:,3], dtype=float)
	charge		 	=	np.array(ls[:,4], dtype=float)
	sigma		 	=	np.array(ls[:,6], dtype=float)*10. 	# nm -> angstroms
	eps		 	=	np.array(ls[:,7], dtype=float)/4.184	# kJ/mol -> kcal/mol

	# Dictionary of LAMMPS Atom type: [OPLS nonbonded type, OPLS bonded type]
	defined_types = {}
        opls_types = {}
	for n, atom in g.nodes(data=True):
		a_type = atom['atom_type']

		# See if type has already been defined
		if a_type not in defined_types.keys():
			# Look for OPLS types with same properties (to within a certain percentage)
			a_m = atom['mass']
			a_c = atom['charge']
			a_s = atom['sigma']
			a_e = atom['eps']

			match_m = _percent_diff(a_m, mass)
			match_c = _percent_diff(a_c, charge)
			match_s = _percent_diff(a_s, sigma)
			match_e = _percent_diff(a_e, eps)

			# Indices of common matches
			ind = np.nonzero(match_m & match_c & match_s & match_e)[0]

			if len(ind) == 1:
				# 1 match
				defined_types[a_type] = [bonded_types[ind[0]]]
                                opls_types[a_type] = nonbonded_types[ind[0]]
			else:
				bt = ln._removeDuplicatesArray(bonded_types[ind])
				defined_types[a_type] = bt
                                opls_types[a_type] = nonbonded_types[ind[0]]

		atom['opls_bonded_type']	= defined_types[a_type]
		atom['opls_nonbonded_type']	= opls_types[a_type]

	return defined_types



def _refine_opls_types_from_bonds(g, defined_types, tk, lammps_coefficients, fflocation='./gmx/'):
	"""	Refines defined atom types using bond coefficients, by comparing to OPLS:

		- Takes dictionary of list of possible bonded type candidates for
			each atom type i.e. {1:['CT', 'CY'] , 2:['HC'], 3:['CM','C='], ... }
		- If a list is of length 1, the types are already uniquely defined,
			so nothing is done.
		- Otherwise, the bonds involving the given atom type are tabulated from
			the type_key dictionary (generated by lmp2nx.lmp2nx()), and their
			coefficients looked up from lammps_coefficients.
		- Matching coefficients k0 (bond strength) and b0 (equilibrium bond
			length) are then looked up in the OPLS force-field tabulated by gromacs,
			in the file fflocation+'ffbonded.itp' (default './gmx/ffbonded.itp').
			This will generate matching bonds e.g. "CT-CT_1", "CT-CT_2", "CT-CY" etc.
		- From this the bonded type is refined.

		Input:
			- network of atoms and bonds created by lmp2nx.lmp2nx()
			- defined_types dictionary, generated by define_opls_types(), consisting of
			{LAMMPS atom type: list of possible bonded types}.
			- type_key dictionary, generated by lmp2nx.lmp2nx(), consisting of dictionaries
			for each bonded interaction and the related type e.g. tk['bond']['1-1'] = 1
			- lammps coefficients (dictionary of list of lists), generated by lmp2nx.
		Output:
			- refines 'opls_bonded_type' for each atom in g
			- returns new defined types array
	"""

	# Read bonded section of ffbonded.itp from gromacs
	with open(fflocation+'ffbonded.itp') as f:
		ls=[l.strip() for l in f.readlines()]
	bond_lines = (ls.index('[ bondtypes ]')+2, ls.index('[ constrainttypes ]')-1)
	ls=[l.strip().split()[:5] for l in ls[bond_lines[0]: bond_lines[1]]]
	# List of [bond_type, bond_type] e.g. [CT,CT], [CT,CY], ...
	all_names=np.array([l[:2] for l in ls])
	# List of equilibrium separations in angstroms
	all_b0=np.array([l[3] for l in ls], dtype=float)*10.
	# List of bond strengths in kcal / mol angstrom^2
	all_k0=np.array([l[4] for l in ls], dtype=float)*0.5*0.01/4.184

	rtk={}
	for a,b in tk['bond'].iteritems():
		asplit=[int(i) for i in a.split('-')]
		for ai in asplit:
			if ai in rtk.keys():
				rtk[ai].append(b)
			else:
				rtk[ai]=[b]
	for a, b in rtk.iteritems():
		rtk[a] = ln._removeDuplicates(b)

	rtkbond={}
	for a,b in tk['bond'].iteritems():
		asplit=[int(i) for i in a.split('-')]
		if b in rtkbond.keys():
			if asplit not in rtkbond[b] and asplit[::-1] not in rtkbond[b]:
				rtkbond[b].append(asplit)
		else:
			rtkbond[b]=[asplit]

	new_defined_types={}
	for atom_type, bonded_type in defined_types.iteritems():
		if len(bonded_type) == 1:
			# If only bonded type for a given atom type, bonded type is already defined
			new_defined_types[atom_type] = bonded_type[0]
			continue
		else:
			bonds_to_check = rtk[atom_type]

			total_match = []
			found = False
			for i in bonds_to_check:
				if found is True: break

				# For the given bond i, look for matches between the LAMMPS coefficients
				#	and the tabulated gromacs ones.
				bond_k0 	= 	lammps_coefficients['bond'][i-1][1]
				bond_b0 	= 	lammps_coefficients['bond'][i-1][2]
				match_k0 	= 	_percent_diff(bond_k0, all_k0)
				match_b0 	= 	_percent_diff(bond_b0, all_b0)
				match_ind 	= 	np.nonzero(match_k0 & match_b0)
				match_names = 	all_names[match_ind, :][0]

				# Bonded atom types involved in bond i
				for bond_j in rtkbond[i]:
					if atom_type not in bond_j: continue
					ai = defined_types[bond_j[0]]
					aj = defined_types[bond_j[1]]
					if ai == aj:
						same = True
					else:
						same = False

					bond_match = []

					if len(match_names) == 0:
						print 'ERROR: no matches?'
					else:
						for m1, m2 in match_names:
							if same is False:
								if m1 in ai and m2 in aj:
									match=np.intersect1d(bonded_type, [m1,m2])
									bond_match += list(match)
								elif m1 in aj and m2 in ai:
									match=np.intersect1d(bonded_type, [m1,m2])
									bond_match += list(match)
							else:
								if ai[0]==m1 and ai[0]==m2:
									bond_match += [ai[0]]
								elif ai[1]==m1 and ai[1]==m2:
									bond_match += [ai[1]]

					bond_match = ln._removeDuplicates(bond_match)
					if len(bond_match) == 1:
						total_match = bond_match
						found = True
					else:
						total_match += bond_match
			total_match = ln._removeDuplicates(total_match)
			assert len(total_match) == 1
			new_defined_types[atom_type] = total_match[0]


	# Correct opls_bonded_type in network g
	for n, atom in g.nodes(data=True):
		atom['opls_bonded_type'] = new_defined_types[atom['atom_type']]

	return new_defined_types



def equivalent_bonds(defined_types, tk):
	""" Defines equivalent bonds in type key given bonded types

	- Given N distinct atom types, n<N may have similar bonded types e.g. opls_136
	and opls_137 both have bonded type CT. Therefore there exist coefficients for
	extra bonded interactions (bonds/angles/dihedrals) defined using the LAMMPS atom
	types 1-N. This function seeks to find them.

	Input:
		- dictionary of uniquely defined types i.e. {atom type 1: CT} etc.
		- type key of all bonded interactions
	Output:
		- new type key with equivalent interactions added
	"""
	reversed_defined_types = {}
	for atom_type, bonded_type in defined_types.iteritems():
		if bonded_type in reversed_defined_types.keys():
			reversed_defined_types[bonded_type].append(atom_type)
		else:
			reversed_defined_types[bonded_type]= [atom_type]

	new_tk = copy.deepcopy(tk)
	# Every atom in a_types has equivalent bonded interactions
	for bonded, values in tk.iteritems():
		for key, bond_type in values.iteritems():
			akey = key.split('-')
			alt = [reversed_defined_types[defined_types[int(a_i)]] for a_i in akey]
			combs = list(it.product(*alt))
			for c in combs:
				cstr = '-'.join([str(el) for el in c])
				if cstr in new_tk[bonded].keys():
					assert new_tk[bonded][cstr] == bond_type
				else:
					new_tk[bonded][cstr] = bond_type

	return new_tk




def _look_up_params(bond, fflocation='./gmx/'):
	""" Looks up OPLS parameters for a given bonded interaction

	Input:
		- bond as list of bonded types e.g. ['CT', 'CT', 'CT'] (bond type i.e.
			bond/angle/dihedral is assumed from length of list)
		- location of the OPLS force-field as tabulated in ffbonded.itp in gromacs
	Output:
		- list of parameters in LAMMPS real units (kcal/mol angstrom^2 etc.)
	"""
	with open(fflocation+'ffbonded.itp') as f:
		ls = f.readlines()

	# Line numbers for bonds, angles, dihedrals sections in ffbonded.itp
	line_ranges = {2:(5,304), 3:(374,1302), 4:(1312,2454)}
	nb 			= len(bond)
	if nb < 2 or nb > 4:
		print 'ERROR: incorrect bond length,', nb, 'for bond', bond
		return

	line_range  = line_ranges[nb]
	section 	= ls[line_range[0]:line_range[1]]
	# Divide lines into lists, ignoring comments
	section 	= [l.strip().split(';')[0].split() for l in section]

	matches 	= []
	for l in section:
		atoms 	= l[:nb]
		nmatch	= 0
		rnmatch	= 0
		for i in range(nb):
			# Check forwards
			if atoms[i] == bond[i] or atoms[i] == 'X':
				nmatch += 1
			# Check reverse
			if atoms[-1-i] == bond[i] or atoms[-1-i] == 'X':
				rnmatch +=1

		if nmatch==nb or rnmatch==nb:
			matches.append(l)

	if len(matches) == 0:
		print 'ERROR: no matches found'
		return None
	elif len(matches) > 1:
		print 'ERROR: more than one match found. \n Matches:', matches
		return None
	else:
		l = matches[0]

	# Convert units
	if nb == 2:
		coeffs = l[nb+1:nb+1+2]
		b0 = float(coeffs[0])*10.
		k0 = float(coeffs[1])*0.5*0.01/4.184
		# LAMMPS takes k0, b0
		return round(k0,3), round(b0,3)
	elif nb == 3:
		coeffs = l[nb+1:nb+1+2]
		th0 = float(coeffs[0])
		cth = 0.5*float(coeffs[1])/4.184
		# LAMMPS takes cth, th0
		return round(cth,3), round(th0,3)
	elif nb == 4:
		coeffs = np.array(l[nb+1:nb+1+5], dtype=float)/4.184
		f1 = _round_to_zero(-2.*coeffs[1]-1.5*coeffs[3])
		f2 = _round_to_zero(-coeffs[4]-coeffs[2])
		f3 = _round_to_zero(-coeffs[3]/2.)
		f4 = _round_to_zero(-coeffs[4]/4.)
		# LAMMPS takes fourier dihedrals; f1,f2,f3,f4
		return f1, f2, f3, f4


def look_up_nonbonded_params(opls_type, fflocation='./gmx/'):
	with open(fflocation + 'ffnonbonded.itp') as f:
		ls = [l.strip().split() for l in f.readlines() if l[0]!=';' and l[0]!='[']

	result = {}
	for l in ls:
		if l[0] == opls_type:
			result['atom_type'] = l[1]
			result['bond_type'] = int(l[2])
			result['mass'] = float(l[3])
			result['charge'] = float(l[4])
			result['ptype'] = l[5]
			result['sigma'] = float(l[6])
			result['epsilon'] = float(l[7])
			return result

	return None




def add_new_params_to_lammps(bond, lammps_coefficients, fflocation='./gmx/'):
	params = _look_up_params(bond, fflocation)
	nb = len(bond)
	bonded_type = {2:'bond', 3:'angle', 4:'dihedral'}[nb]
	last_n = int(lammps_coefficients[bonded_type][-1][0])
	pline = [last_n+1]+list(params)
	print 'pline = ', pline
	lammps_coefficients[bonded_type].append(pline)
	return last_n+1



def add_new_bonds_to_bond_types(bond, bond_types, opls_types, bond_n=None):
	nb = len(bond)
	bonded_type = {2:'bond', 3:'angle', 4:'dihedral'}[nb]
	bond_atoms = []
	for bi in bond:
		for atom_type, bonded in opls_types.iteritems():
			if bi == bonded:
				bond_atoms.append(str(atom_type))
				break

	if len(bond_atoms) != len(bond):
		print 'ERROR: bonded types ', bond, 'not found in OPLS types', opls_types
		return

	if bond_n is None:
		bond_n = max(bond_types[bonded_type].values())+1

	key = '-'.join(bond_atoms)
	bond_types[bonded_type][key] = bond_n

	return


def numbers_to_types(opls_types, bond_types):
	new_types = {}
	for k in bond_types.keys():
		new_types[k] = {}
		for bond, btype in bond_types[k].iteritems():
			batoms = '-'.join([opls_types[int(b)] for b in bond.split('-')])
			if batoms in new_types[k].keys():
				assert new_types[k][batoms] == btype
			else:
				new_types[k][batoms] = btype
	return new_types



def _percent_diff(target, list, percent=0.1):
	"""	 Looks for close numerical matches between target value and list of values

		- Input:
			- target value
			- list of values to search through
			- target percentage (i.e. match if percentage difference < percent)
		- Output:
			- numpy array of boolean list of matches
	"""
	pc = [100.0*abs(float(val)-float(target))/abs(float(target)) for val in list]

	return np.array(pc,dtype=float)<float(percent)



def _round_to_zero(num):
	if abs(float(num))<0.00001:
		return 0.
	else:
		return round(num,6)
